<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Interval.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">waiver-petition-assignment</a> &gt; <a href="index.source.html" class="el_package">intervals</a> &gt; <span class="el_source">Interval.java</span></div><h1>Interval.java</h1><pre class="source lang-java linenums">package intervals;

import java.util.Objects;

/**
 * This class represents a 1-dimensional interval. The interval is
 * characterized by a start and an end, both integral values.
 */
public class Interval {
  private int start;
  private int end;

  /**
   * Construct an interval given its start and end values.
   *
   * @param start the start
   * @param end the end
   * @throws IllegalArgumentException if start is greater than end
   */
<span class="fc" id="L20">  public Interval(int start, int end) throws IllegalArgumentException {</span>
<span class="fc bfc" id="L21" title="All 2 branches covered.">    if (start &gt; end) {</span>
<span class="fc" id="L22">      throw new IllegalArgumentException(&quot;Invalid interval&quot;);</span>
    }
<span class="fc" id="L24">    this.start = start;</span>
<span class="fc" id="L25">    this.end = end;</span>
<span class="fc" id="L26">  }</span>

  /**
   * Compute and return an interval that represents the intersection of this
   * and another interval. The intersection is defined as the smallest
   * interval that overlaps with both intervals. If no intersection exists,
   * return an interval with equal and very low start and end values.
   *
   * @param other the other interval
   * @return the interval that is the intersection of this and the other
   *         interval
   */
  public Interval intersect(Interval other) {
<span class="fc" id="L39">    int min = Math.max(this.start, other.start);</span>
<span class="fc" id="L40">    int max = Math.min(this.end, other.end);</span>
<span class="fc bfc" id="L41" title="All 2 branches covered.">    if (min &gt; max) {</span>
<span class="fc" id="L42">      min = Integer.MIN_VALUE;</span>
<span class="fc" id="L43">      max = Integer.MIN_VALUE;</span>
    }
<span class="fc" id="L45">    return new Interval(min, max);</span>
  }

  /**
   * Computes and returns the union of this and another interval. The union is
   * defined as the smallest interval that both intervals overlap with.
   *
   * @param other the other interval
   * @return the union of the two intervals
   */
  public Interval union(Interval other) {
<span class="fc" id="L56">    return new Interval(Math.min(this.start, other.start),</span>
<span class="fc" id="L57">        Math.max(this.end, other.end));</span>
  }

  /**
   * Return a string-representation of this interval.
   *
   * @return a string of the format start,end
   */
  public String toString() {
<span class="fc" id="L66">    return &quot;&quot; + start + &quot;,&quot; + end;</span>
  }

  /**
   * Sameness test for two intervals. Two intervals are deemed to be equal to
   * each other if their start and end values coincide.
   *
   * @param other the other object to be tested for equality
   * @return true if the two intervals are equal, false otherwise
   */
  @Override
  public boolean equals(Object other) {
<span class="fc bfc" id="L78" title="All 2 branches covered.">    if (this == other) {</span>
<span class="fc" id="L79">      return true;</span>
    }

<span class="fc bfc" id="L82" title="All 2 branches covered.">    if (!(other instanceof Interval)) {</span>
<span class="fc" id="L83">      return false;</span>
    }
<span class="fc" id="L85">    Interval otherInterval = (Interval) other;</span>
<span class="fc bfc" id="L86" title="All 4 branches covered.">    return this.start == otherInterval.start &amp;&amp; this.end == otherInterval.end;</span>
  }

  /**
   * Hashcode for the interval, using start and end.
   *
   * @return the hash value for this interval
   */
  @Override
  public int hashCode() {
<span class="fc" id="L96">    return Objects.hash(this.start, this.end);</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>