<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>IntervalTree.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">waiver-petition-assignment</a> &gt; <a href="index.source.html" class="el_package">intervals</a> &gt; <span class="el_source">IntervalTree.java</span></div><h1>IntervalTree.java</h1><pre class="source lang-java linenums">package intervals;

import java.util.Stack;

/**
 * This class represents an expression tree for interval operations.
 * It can parse postfix interval expressions and evaluate them, as well as
 * provide tree visualization.
 */
public class IntervalTree implements Intervals {

    /**
     * Abstract base class for interval expression tree nodes.
     */
    private abstract static class Node {
        abstract Interval evaluate();
        abstract String textTree(String prefix, boolean isLast);
        abstract int getHeight();
    }

    /**
     * Node representing an interval operand.
     */
    private static class IntervalNode extends Node {
        private final Interval interval;

<span class="fc" id="L27">        public IntervalNode(Interval interval) {</span>
<span class="fc" id="L28">            this.interval = interval;</span>
<span class="fc" id="L29">        }</span>

        @Override
        Interval evaluate() {
<span class="fc" id="L33">            return interval;</span>
        }

        @Override
        String textTree(String prefix, boolean isLast) {
<span class="fc" id="L38">            return interval.toString();</span>
        }

        @Override
        int getHeight() {
<span class="nc" id="L43">            return 1;</span>
        }
    }

    /**
     * Node representing a binary operator (Union or Intersection).
     */
    private static class OperatorNode extends Node {
        private final String operator;
        private final Node left;
        private final Node right;

<span class="fc" id="L55">        public OperatorNode(String operator, Node left, Node right) {</span>
<span class="fc" id="L56">            this.operator = operator;</span>
<span class="fc" id="L57">            this.left = left;</span>
<span class="fc" id="L58">            this.right = right;</span>
<span class="fc" id="L59">        }</span>

        @Override
        Interval evaluate() {
<span class="fc" id="L63">            Interval leftInterval = left.evaluate();</span>
<span class="fc" id="L64">            Interval rightInterval = right.evaluate();</span>

<span class="pc bpc" id="L66" title="1 of 3 branches missed.">            switch (operator) {</span>
                case &quot;U&quot;:
<span class="fc" id="L68">                    return leftInterval.union(rightInterval);</span>
                case &quot;I&quot;:
<span class="fc" id="L70">                    return leftInterval.intersect(rightInterval);</span>
                default:
                    // This should never happen if isOperator is correct
<span class="nc" id="L73">                    throw new IllegalArgumentException(&quot;Unknown operator: &quot; + operator);</span>
            }
        }

        @Override
        String textTree(String prefix, boolean isLast) {
<span class="fc" id="L79">            StringBuilder result = new StringBuilder();</span>

            // Add the operator
<span class="fc" id="L82">            result.append(operator).append(&quot;\n&quot;);</span>

            // Add the connecting lines
<span class="fc" id="L85">            result.append(prefix).append(&quot;|\n&quot;);</span>
<span class="fc" id="L86">            result.append(prefix).append(&quot;|\n&quot;);</span>

            // Add the left child with its prefix
<span class="fc" id="L89">            result.append(prefix).append(&quot;|___&quot;);</span>
<span class="fc" id="L90">            String leftResult = left.textTree(prefix + &quot;|   &quot;, false);</span>
<span class="fc" id="L91">            result.append(leftResult);</span>

            // Always add newline after left child
<span class="pc bpc" id="L94" title="1 of 2 branches missed.">            if (!leftResult.endsWith(&quot;\n&quot;)) {</span>
<span class="fc" id="L95">                result.append(&quot;\n&quot;);</span>
            }

            // Add spacing line before right child
<span class="fc" id="L99">            result.append(prefix).append(&quot;|\n&quot;);</span>

            // Add the right child
<span class="fc" id="L102">            result.append(prefix).append(&quot;|___&quot;);</span>
<span class="fc" id="L103">            String rightResult = right.textTree(prefix + &quot;    &quot;, true);</span>
<span class="fc" id="L104">            result.append(rightResult);</span>

            // Don't add trailing newline - parent will handle it

<span class="fc" id="L108">            return result.toString();</span>
        }

        @Override
        int getHeight() {
<span class="nc" id="L113">            return 1 + Math.max(left.getHeight(), right.getHeight());</span>
        }
    }

    private final Node root;

    /**
     * Constructs an IntervalTree from a postfix interval expression string.
     * @param postfixExpression the postfix expression as a space-separated string
     * @throws IllegalArgumentException if the expression is invalid
     */
<span class="fc" id="L124">    public IntervalTree(String postfixExpression) throws IllegalArgumentException {</span>
<span class="fc bfc" id="L125" title="All 4 branches covered.">        if (postfixExpression == null || postfixExpression.trim().isEmpty()) {</span>
<span class="fc" id="L126">            throw new IllegalArgumentException(&quot;Expression cannot be null or empty&quot;);</span>
        }

<span class="fc" id="L129">        this.root = parsePostfix(postfixExpression.trim());</span>
<span class="fc" id="L130">    }</span>

    /**
     * Parses a postfix interval expression and builds the expression tree.
     * @param expression the postfix expression
     * @return the root node of the expression tree
     * @throws IllegalArgumentException if the expression is invalid
     */
    private Node parsePostfix(String expression) throws IllegalArgumentException {
<span class="fc" id="L139">        String[] tokens = expression.split(&quot;\\s+&quot;);</span>
<span class="fc" id="L140">        Stack&lt;Node&gt; stack = new Stack&lt;&gt;();</span>

<span class="fc bfc" id="L142" title="All 2 branches covered.">        for (String token : tokens) {</span>
<span class="fc bfc" id="L143" title="All 2 branches covered.">            if (isOperator(token)) {</span>
                // Check if we have enough operands
<span class="fc bfc" id="L145" title="All 2 branches covered.">                if (stack.size() &lt; 2) {</span>
<span class="fc" id="L146">                    throw new IllegalArgumentException(</span>
                            &quot;Invalid expression: insufficient operands for operator &quot; + token);
                }
                // Pop in reverse order (right first, then left)
<span class="fc" id="L150">                Node right = stack.pop();</span>
<span class="fc" id="L151">                Node left = stack.pop();</span>
<span class="fc" id="L152">                stack.push(new OperatorNode(token, left, right));</span>
<span class="fc" id="L153">            } else {</span>
                // Try to parse as an interval
                try {
<span class="fc" id="L156">                    Interval interval = parseInterval(token);</span>
<span class="fc" id="L157">                    stack.push(new IntervalNode(interval));</span>
<span class="fc" id="L158">                } catch (IllegalArgumentException e) {</span>
<span class="fc" id="L159">                    throw new IllegalArgumentException(&quot;Invalid interval: &quot; + token);</span>
<span class="fc" id="L160">                }</span>
            }
        }

        // Check that we have exactly one element left (the root)
<span class="fc bfc" id="L165" title="All 2 branches covered.">        if (stack.size() != 1) {</span>
<span class="pc bpc" id="L166" title="1 of 2 branches missed.">            if (stack.isEmpty()) {</span>
<span class="nc" id="L167">                throw new IllegalArgumentException(&quot;Invalid expression: no result&quot;);</span>
            } else {
<span class="fc" id="L169">                throw new IllegalArgumentException(</span>
                        &quot;Invalid expression: too many operands&quot;);
            }
        }

<span class="fc" id="L174">        return stack.pop();</span>
    }

    /**
     * Parses an interval string in the format &quot;start,end&quot;.
     * Supports both positive and negative integers.
     * @param intervalStr the interval string
     * @return the parsed Interval object
     * @throws IllegalArgumentException if the format is invalid
     */
    private Interval parseInterval(String intervalStr) throws IllegalArgumentException {
        // Check for basic format - must contain exactly one comma
<span class="fc" id="L186">        int commaIndex = intervalStr.indexOf(',');</span>
<span class="fc bfc" id="L187" title="All 2 branches covered.">        if (commaIndex == -1) {</span>
<span class="fc" id="L188">            throw new IllegalArgumentException(&quot;Invalid interval format: &quot; + intervalStr);</span>
        }

        // Check there's only one comma
<span class="fc bfc" id="L192" title="All 2 branches covered.">        if (intervalStr.indexOf(',', commaIndex + 1) != -1) {</span>
<span class="fc" id="L193">            throw new IllegalArgumentException(&quot;Invalid interval format: &quot; + intervalStr);</span>
        }

        // Extract start and end parts
<span class="fc" id="L197">        String startStr = intervalStr.substring(0, commaIndex).trim();</span>
<span class="fc" id="L198">        String endStr = intervalStr.substring(commaIndex + 1).trim();</span>

        // Both parts must be non-empty
<span class="fc bfc" id="L201" title="All 4 branches covered.">        if (startStr.isEmpty() || endStr.isEmpty()) {</span>
<span class="fc" id="L202">            throw new IllegalArgumentException(&quot;Invalid interval format: &quot; + intervalStr);</span>
        }

        try {
<span class="fc" id="L206">            int start = Integer.parseInt(startStr);</span>
<span class="fc" id="L207">            int end = Integer.parseInt(endStr);</span>
<span class="fc" id="L208">            return new Interval(start, end);</span>
<span class="fc" id="L209">        } catch (NumberFormatException e) {</span>
<span class="fc" id="L210">            throw new IllegalArgumentException(&quot;Invalid interval values: &quot; + intervalStr);</span>
        }
    }

    /**
     * Checks if a token is a valid operator.
     * @param token the token to check
     * @return true if the token is an operator, false otherwise
     */
    private boolean isOperator(String token) {
<span class="fc bfc" id="L220" title="All 4 branches covered.">        return token.equals(&quot;U&quot;) || token.equals(&quot;I&quot;);</span>
    }

    @Override
    public Interval evaluate() {
<span class="fc" id="L225">        return root.evaluate();</span>
    }

    @Override
    public String textTree() {
<span class="fc" id="L230">        return root.textTree(&quot;&quot;, true);</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>