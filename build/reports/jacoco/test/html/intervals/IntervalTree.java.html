<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>IntervalTree.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">waiver-petition-assignment</a> &gt; <a href="index.source.html" class="el_package">intervals</a> &gt; <span class="el_source">IntervalTree.java</span></div><h1>IntervalTree.java</h1><pre class="source lang-java linenums">package intervals;

import java.util.Stack;

/**
 * Interval expression tree implementation for union, intersection operations.
 * Parses postfix notation and builds a tree structure.
 */
public class IntervalTree implements Intervals {

  /**
   * Base node class for the tree.
   */
  private abstract static class Node {
    /**
     * Evaluate the node and get its interval.
     *
     * @return resulting interval
     */
    abstract Interval evaluate();

    /**
     * Get text representation of subtree.
     *
     * @param prefix spacing prefix
     * @param isLast is this the last child
     * @return formatted tree string
     */
    abstract String textTree(String prefix, boolean isLast);

    /**
     * Get tree height.
     *
     * @return height
     */
    abstract int getHeight();
  }

  /**
   * Leaf node containing an interval.
   */
  private static class IntervalNode extends Node {
    private final Interval interval;

    /**
     * Create leaf node.
     *
     * @param interval the interval to store
     */
<span class="fc" id="L50">    public IntervalNode(Interval interval) {</span>
<span class="fc" id="L51">      this.interval = interval;</span>
<span class="fc" id="L52">    }</span>

    @Override
    Interval evaluate() {
<span class="fc" id="L56">      return interval;</span>
    }

    @Override
    String textTree(String prefix, boolean isLast) {
<span class="fc" id="L61">      return interval.toString();</span>
    }

    @Override
    int getHeight() {
<span class="nc" id="L66">      return 1;</span>
    }
  }

  /**
   * Internal node for operators (U or I).
   */
  private static class OperatorNode extends Node {
    private final String operator;
    private final Node left;
    private final Node right;

    /**
     * Create operator node.
     *
     * @param operator U for union, I for intersection
     * @param left left subtree
     * @param right right subtree
     */
<span class="fc" id="L85">    public OperatorNode(String operator, Node left, Node right) {</span>
<span class="fc" id="L86">      this.operator = operator;</span>
<span class="fc" id="L87">      this.left = left;</span>
<span class="fc" id="L88">      this.right = right;</span>
<span class="fc" id="L89">    }</span>

    @Override
    Interval evaluate() {
<span class="fc" id="L93">      Interval leftInterval = left.evaluate();</span>
<span class="fc" id="L94">      Interval rightInterval = right.evaluate();</span>

<span class="pc bpc" id="L96" title="1 of 3 branches missed.">      switch (operator) {</span>
        case &quot;U&quot;:
<span class="fc" id="L98">          return leftInterval.union(rightInterval);</span>
        case &quot;I&quot;:
<span class="fc" id="L100">          return leftInterval.intersect(rightInterval);</span>
        default:
          // shouldn't happen with valid input
<span class="nc" id="L103">          throw new IllegalArgumentException(&quot;Unknown operator: &quot; + operator);</span>
      }
    }

    @Override
    String textTree(String prefix, boolean isLast) {
<span class="fc" id="L109">      StringBuilder result = new StringBuilder();</span>

      // Add operator at top
<span class="fc" id="L112">      result.append(operator).append(&quot;\n&quot;);</span>

      // Vertical lines
<span class="fc" id="L115">      result.append(prefix).append(&quot;|\n&quot;);</span>
<span class="fc" id="L116">      result.append(prefix).append(&quot;|\n&quot;);</span>

      // Left child
<span class="fc" id="L119">      result.append(prefix).append(&quot;|___&quot;);</span>
<span class="fc" id="L120">      String leftResult = left.textTree(prefix + &quot;|   &quot;, false);</span>
<span class="fc" id="L121">      result.append(leftResult);</span>

      // Add newline if needed
<span class="pc bpc" id="L124" title="1 of 2 branches missed.">      if (!leftResult.endsWith(&quot;\n&quot;)) {</span>
<span class="fc" id="L125">        result.append(&quot;\n&quot;);</span>
      }

      // Spacing before right child
<span class="fc" id="L129">      result.append(prefix).append(&quot;|\n&quot;);</span>

      // Right child
<span class="fc" id="L132">      result.append(prefix).append(&quot;|___&quot;);</span>
<span class="fc" id="L133">      String rightResult = right.textTree(prefix + &quot;    &quot;, true);</span>
<span class="fc" id="L134">      result.append(rightResult);</span>

<span class="fc" id="L136">      return result.toString();</span>
    }

    @Override
    int getHeight() {
<span class="nc" id="L141">      return 1 + Math.max(left.getHeight(), right.getHeight());</span>
    }
  }

  private final Node root;

  /**
   * Build tree from postfix expression.
   *
   * @param postfixExpression space-separated postfix string
   * @throws IllegalArgumentException for invalid expressions
   */
<span class="fc" id="L153">  public IntervalTree(String postfixExpression) throws IllegalArgumentException {</span>
<span class="fc bfc" id="L154" title="All 4 branches covered.">    if (postfixExpression == null || postfixExpression.trim().isEmpty()) {</span>
<span class="fc" id="L155">      throw new IllegalArgumentException(&quot;Expression cannot be null or empty&quot;);</span>
    }

<span class="fc" id="L158">    this.root = parsePostfix(postfixExpression.trim());</span>
<span class="fc" id="L159">  }</span>

  /**
   * Parse postfix and build tree using stack.
   *
   * @param expression postfix string
   * @return root of tree
   * @throws IllegalArgumentException if malformed
   */
  private Node parsePostfix(String expression) throws IllegalArgumentException {
<span class="fc" id="L169">    String[] tokens = expression.split(&quot;\\s+&quot;);</span>
<span class="fc" id="L170">    Stack&lt;Node&gt; stack = new Stack&lt;&gt;();</span>

<span class="fc bfc" id="L172" title="All 2 branches covered.">    for (String token : tokens) {</span>
<span class="fc bfc" id="L173" title="All 2 branches covered.">      if (isOperator(token)) {</span>
        // Need two operands for binary operator
<span class="fc bfc" id="L175" title="All 2 branches covered.">        if (stack.size() &lt; 2) {</span>
<span class="fc" id="L176">          throw new IllegalArgumentException(</span>
              &quot;Invalid expression: insufficient operands for operator &quot; + token);
        }
        // Pop right then left (reverse order)
<span class="fc" id="L180">        Node right = stack.pop();</span>
<span class="fc" id="L181">        Node left = stack.pop();</span>
<span class="fc" id="L182">        stack.push(new OperatorNode(token, left, right));</span>
<span class="fc" id="L183">      } else {</span>
        // Must be an interval
        try {
<span class="fc" id="L186">          Interval interval = parseInterval(token);</span>
<span class="fc" id="L187">          stack.push(new IntervalNode(interval));</span>
<span class="fc" id="L188">        } catch (IllegalArgumentException e) {</span>
<span class="fc" id="L189">          throw new IllegalArgumentException(&quot;Invalid interval: &quot; + token);</span>
<span class="fc" id="L190">        }</span>
      }
    }

    // Should have exactly one node left
<span class="fc bfc" id="L195" title="All 2 branches covered.">    if (stack.size() != 1) {</span>
<span class="pc bpc" id="L196" title="1 of 2 branches missed.">      if (stack.isEmpty()) {</span>
<span class="nc" id="L197">        throw new IllegalArgumentException(&quot;Invalid expression: no result&quot;);</span>
      } else {
<span class="fc" id="L199">        throw new IllegalArgumentException(</span>
            &quot;Invalid expression: too many operands&quot;);
      }
    }

<span class="fc" id="L204">    return stack.pop();</span>
  }

  /**
   * Parse &quot;start,end&quot; format into Interval.
   * Handles negative numbers.
   *
   * @param intervalStr string to parse
   * @return new Interval
   * @throws IllegalArgumentException if bad format
   */
  private Interval parseInterval(String intervalStr) throws IllegalArgumentException {
    // Find comma separator
<span class="fc" id="L217">    int commaIndex = intervalStr.indexOf(',');</span>
<span class="fc bfc" id="L218" title="All 2 branches covered.">    if (commaIndex == -1) {</span>
<span class="fc" id="L219">      throw new IllegalArgumentException(&quot;Invalid interval format: &quot; + intervalStr);</span>
    }

    // Check for multiple commas
<span class="fc bfc" id="L223" title="All 2 branches covered.">    if (intervalStr.indexOf(',', commaIndex + 1) != -1) {</span>
<span class="fc" id="L224">      throw new IllegalArgumentException(&quot;Invalid interval format: &quot; + intervalStr);</span>
    }

    // Split at comma
<span class="fc" id="L228">    String startStr = intervalStr.substring(0, commaIndex).trim();</span>
<span class="fc" id="L229">    String endStr = intervalStr.substring(commaIndex + 1).trim();</span>

    // Both parts must exist
<span class="pc bpc" id="L232" title="1 of 4 branches missed.">    if (startStr.isEmpty() || endStr.isEmpty()) {</span>
<span class="fc" id="L233">      throw new IllegalArgumentException(&quot;Invalid interval format: &quot; + intervalStr);</span>
    }

    try {
<span class="fc" id="L237">      int start = Integer.parseInt(startStr);</span>
<span class="fc" id="L238">      int end = Integer.parseInt(endStr);</span>
<span class="fc" id="L239">      return new Interval(start, end);</span>
<span class="fc" id="L240">    } catch (NumberFormatException e) {</span>
<span class="fc" id="L241">      throw new IllegalArgumentException(&quot;Invalid interval values: &quot; + intervalStr);</span>
    }
  }

  /**
   * Check if token is U or I operator.
   *
   * @param token string to check
   * @return true if operator
   */
  private boolean isOperator(String token) {
<span class="fc bfc" id="L252" title="All 4 branches covered.">    return token.equals(&quot;U&quot;) || token.equals(&quot;I&quot;);</span>
  }

  @Override
  public Interval evaluate() {
<span class="fc" id="L257">    return root.evaluate();</span>
  }

  @Override
  public String textTree() {
<span class="fc" id="L262">    return root.textTree(&quot;&quot;, true);</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>